<!DOCTYPE html>
<html>
<head>
  <title>Logcat viewer</title>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.1/css/bulma.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.1/Chart.min.js"></script>
  <script src="https://unpkg.com/vue-chartjs/dist/vue-chartjs.min.js"></script>
  <script src="https://unpkg.com/vue"></script>
</head>
<body>
  <div id="app">

    <div class="box is-danger" v-if="lines.connectionClosed">
      Connection IS Closed
    </div>

    <div class="field">
      <label class="checkbox">
        <input type="checkbox" @click="onPauseClicked" v-model="isPaused">
        Pause
      </label>
    </div>

    <div class="container is-fluid columns">

      <div class="column is-half">
        <div class="graphLabels">
          <div class="graphLabel" v-for="pair in pairs">
            <div>{{ pair[0] }}</div>
            <div :style="{ backgroundColor: pair[1] }">{{ slices[pair[0]][ slices[pair[0]].length - 1 ] }}</div>
          </div>
        </div>
        <div class="chartContainer">
          <line-chart :chart-data="chartData"></line-chart>
        </div>
        <div style="height: 700px; overflow-y: scroll">
          <table class="table is-bordered is-striped is-narrow is-hoverable is-fullwidth">
            <thead>
              <tr>
                <th>Step</th><th>Java Heap</th><th>Native Heap</th><th>Code</th><th>Graphics</th><th>Private Other</th><th>System</th><th>Total</th>
              </tr>
            </thead>
            <tbody>
              <tr v-bind:class="{ 'is-selected': (line === selected) }" v-on:click="selectLine(line)" v-for="line in linesComputed">
                <td>{{ line.step }}</td>
                <td>{{ line.java_heap }}</td><td>{{ line.native_heap }}</td><td>{{ line.code }}</td><td>{{ line.graphics }}</td><td>{{ line.private_other }}</td>
                <td>{{ line.system }}</td><td>{{ line.total }}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="column is-half">
        <div class="chartContainer">
          <line-chart :chart-data="snapshotData"></line-chart>
        </div>
        <div style="height: 700px; overflow-y: scroll">
          <table class="table is-bordered is-striped is-narrow is-hoverable is-fullwidth">
            <thead>
              <tr>
                <th>Step</th><th>Java Heap</th><th>Native Heap</th><th>Code</th><th>Graphics</th><th>Private Other</th><th>System</th><th>Total</th>
              </tr>
            </thead>
            <tbody>
              <tr v-on:click="selectSnapshot(line)" v-for="line in reverseSnapshots">
                <td>{{ line.step }}</td>
                <td>{{ line.java_heap }}</td><td>{{ line.native_heap }}</td><td>{{ line.code }}</td><td>{{ line.graphics }}</td><td>{{ line.private_other }}</td>
                <td>{{ line.system }}</td><td>{{ line.total }}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

  </div>

  <script>

    const chartColors = {
      red: 'rgb(255, 99, 132)',
      orange: 'rgb(255, 159, 64)',
      yellow: 'rgb(255, 205, 86)',
      green: 'rgb(75, 192, 192)',
      blue: 'rgb(54, 162, 235)',
      purple: 'rgb(153, 102, 255)',
      grey: 'rgb(201, 203, 207)'
    };
    const pairs = [
    ['java_heap', chartColors.blue],
    ['native_heap', chartColors.orange],
    ['graphics', chartColors.yellow],
    ['code', chartColors.green],
    ['private_other', chartColors.purple],
    ['system', chartColors.grey],
    ['total', '']
    ]
    let lines = {data: [], isPaused: false, connectionClosed: false};
    let slices = {java_heap: [], native_heap: [], code: [], graphics: [], private_other: [], system: [], total: [], step: []}
    let cleared = [];
    const sliceCount = 20
    let step = 0

    function createDataset(name, color) {
      return {
        backgroundColor: color,
        data: slices[name].slice(-1 * sliceCount)
      }
    }

    Vue.component('line-chart', {
      extends: VueChartJs.Line,
      mixins: [VueChartJs.mixins.reactiveProp],
      props: ['chartData'],
      mounted () {
        this.renderChart(this.chartData, {
          responsive: true,
          maintainAspectRatio: false,
          animation: {
            duration: 0
          },
          hover: {
            animationDuration: 300,
          },
          responsiveAnimationDuration: 0,
          legends: {
            display: false
          },
          scales: {
            xAxes: [{
              display: true,
              ticks: {
                beginAtZero:true,
                labelString: 'Type',
              }
            }],
            yAxes: [{
              stacked: true,
              display: true,
              ticks: {
                beginAtZero:true,
                labelString: 'mem',
              }
            }]
          }
        })
      }
    })
    var app = new Vue({
      el: '#app',
      data: {
        lines: lines,
        slices: slices,
        pairs: pairs,
        enabledDataSets: { java_heap: true, native_heap: true, code: true, graphics: true, private_other: false, system: false },
        selected: {},
        snapshots: [],
        isPaused: false,
        isCollapsed: true,
      },
      methods: {
        selectLine(line) {
          this.selected = line;
          this.snapshots = this.snapshots.slice()
          this.snapshots.push(line)
        },
        selectSnapshot(line) {
          const i = this.snapshots.indexOf(line)
          if (i != -1) {
            this.snapshots.splice(i, 1)
          }
          this.snapshots = this.snapshots.slice()
        },
        onPauseClicked() {
          this.isPaused = !this.isPaused;
          this.lines.isPaused = this.isPaused;
        },
        clearLogs() {
          this.lines.data = [];
        },
      },

      computed: {
        linesComputed() {
          const slice = lines.data.slice(-50)
          slice.reverse()
          return slice
        },
        reverseSnapshots() {
          let reverse = this.snapshots.slice()
          reverse.sort((a, b) => {
            return a.step > b.step && -1 || 1
          })
          return reverse
        },
        snapshotData() {
          console.log(this.snapshots)
          const datasets = this.pairs
          .filter((pair) => { return this.enabledDataSets[pair[0]]})
          .map((pair) => {
            const slice = this.snapshots.slice(-1 * sliceCount).map((snapshot) => { return snapshot[pair[0]] })
            return {
              backgroundColor: pair[1],
              data: slice,
            }
          })
          datasets
          let labels = this.snapshots.map((s) => s.step)
          for (let index = labels.length; index < sliceCount; index++) {
            labels[index] = '_'
          }

          return {
            datasets,
            labels,
          }
        },
        chartData() {
          const last = slices.java_heap.length -1
          const datasets = []

          this.pairs.forEach((pair) => {
            if (this.enabledDataSets[pair[0]]) {
              datasets.push(createDataset(pair[0], pair[1]))
            }
          })

          let labels = slices.step.slice(-1 * sliceCount)
          for (let index = labels.length; index < sliceCount; index++) {
            labels[index] = '_'
          }

          const data = {
            labels: labels,
            datasets: datasets,
          }
          console.log(data)
          return data
        }
      },
    })

    window.WebSocket = window.WebSocket || window.MozWebSocket;

    var connection = new WebSocket('ws://127.0.0.1:3000');

    connection.onopen = function () {
      // connection is opened and ready to use
      console.log("Connection open")
    };

    connection.onclose = function (error) {
      lines.connectionClosed = true;
      console.log("Connection closed")
    };

    connection.onerror = function (error) {
      lines.connectionClosed = true;
      console.log("Connection error")
    };

    connection.onmessage = function (message) {
      console.log('onMessage: '+message)
      if (lines.isPaused) {
        return;
      }

      if (lines.data.length > 50000) {
        lines.data = lines.data.slice(-10000);
      }

      try {
        var json = JSON.parse(message.data);

        step += 1
        pairs.forEach((pair) => {
          slices[pair[0]].push(json[pair[0]])
        })
        slices.step.push(step)
        json.step = step
        lines.data.push(json);
      } catch (e) {
        console.log('This doesn\'t look like a valid JSON: ',
        message.data);
        return;
      }
    };
  </script>
  <style type="text/css">
    .collapsedCellMessage {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 500px;
    }

    .collapsedCellTag {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 150px;
    }

    .graphLabels {
      display: flex;
      flex-direction: row;
    }

    .graphLabel {
      border: 1px solid;
      margin: 8px;
      display: flex;
      flex-direction: row;
    }

    .graphLabel > * {
      margin: 4px;
    }

    .chartContainer {
      height: 500px;
    }
  </style>
</body>
</html>
